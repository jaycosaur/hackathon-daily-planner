import React, {useCallback, useMemo, useState} from "react";
import {AppContext} from "./AppContext";
import {IAppContextValue} from "../types/IAppContextValue";
import {IUser} from "../types/IUser";
import {useQuery} from "react-query";
import {ITask} from "../types/ITask";
import {ITaskImage} from "../types/ITaskImage";

const serverBaseUrl = "https://spineless.xyz/prp-daily-planner-1";

const useUsers = () => {
  return useQuery<{}, {}, IUser[]>({
    queryKey: "users",
    refetchInterval: 60 * 1000, // refetch users every 60 seconds
    queryFn: async () => {
      // please don't tell anyone how I live
      const result = await (await fetch(serverBaseUrl + "/users")).json();
      return result.items;
    }
  });
}

async function createUser(user: IUser): Promise<IUser> {
  const response = await fetch(serverBaseUrl + "/users", {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(user)
  });

  return response.json();
}

const useTasks = () => {
  return useQuery<{}, {}, ITask[]>({
    queryKey: "tasks",
    refetchInterval: 10 * 1000, // refetch tasks every 10 seconds
    queryFn: async () => {
      // please don't tell anyone how I live
      const result = await (await fetch(serverBaseUrl + "/tasks")).json();
      return result.items;
    }
  });
}

export const AppHandler: React.FC = ({children}) => {
  const {isLoading: isLoadingUsers, data: users, refetch: refetchUsers} = useUsers();
  const {isLoading: isLoadingTasks, data: tasks, refetch: refetchTasks} = useTasks();

  const isLoading = isLoadingUsers || isLoadingTasks;

  // TODO: persist session in local storage
  const [activeUser, setActiveUser] = useState<null | IUser>(null);
  const login = useCallback(async (email: string) => {
    if (isLoadingUsers) {
      throw new Error("Cannot login before users are loaded");
    }

    // look for user in users
    const existingUser = users.find(x => x.email === email);

    if (existingUser !== undefined) {
      // user already exists in system, continue with login
      setActiveUser(existingUser);
      return;
    }

    // user doesn't exist in the database, create them
    const createdUser = await createUser({
      _id: undefined, // will be generated by server
      email
    });

    // re-fetch the list of users in the system before we continue
    await refetchUsers();

    setActiveUser(createdUser);
  }, [isLoadingUsers, users, refetchUsers, setActiveUser]);

  const createTask = useCallback(async (task: ITask) => {
    const response = await fetch(serverBaseUrl + "/tasks", {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(task)
    });

    const createdTask = response.json();

    // re-fetch the list of tasks in the system before we return
    await refetchTasks();

    return createdTask;
  }, [refetchTasks]);

  const updateTask = useCallback(async (task: ITask) => {
    await fetch(serverBaseUrl + "/tasks/" + task._id, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(task)
    });

    // re-fetch the list of tasks in the system before we return
    await refetchTasks();
  }, [refetchTasks]);

  const retrieveTaskImage = useCallback(async (imageId: string): Promise<ITaskImage> => {
    const response = await fetch(serverBaseUrl + "/task-images/" + imageId);
    return response.json();
  }, []);

  const providerValue = useMemo<IAppContextValue>(() => ({
    isLoading,

    activeUser,
    users,
    login,

    tasks,
    createTask,
    updateTask,

    retrieveTaskImage
  }), [isLoading, activeUser, users, login, tasks, createTask, updateTask, retrieveTaskImage]);

  return <AppContext.Provider value={providerValue}>
    {children}
  </AppContext.Provider>;
}
